---
title:  Züchtungslehre - Inverse Verwandtschaftsmatrix
author: Peter von Rohr
date: 2016-10-28
output: 
  pdf_document:
    fig_caption: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results = 'asis')
devtools::load_all()
```

```{r DocumentStatus, eval=FALSE}
r6obj_docstat <- rmddochelper::R6ClassDocuStatus$new()
r6obj_docstat$set_current_status(psVersion = "0.0.901",
                                 psStatus  = "Initialisation",
                                 psProject = "ZL_HS_2016")
r6obj_docstat$include_doc_stat(psTitle = "## Document Status")
```


```{r TableAbbreviation}
r6ob_abbrtable <- rmddochelper::R6ClassTableAbbrev$new()
### # include table of abbreviations only, if there are any
if (!r6ob_abbrtable$is_empty_abbr())
  r6ob_abbrtable$include_abbr_table(psAbbrTitle = "## Abbreviations")
```

## Einleitung
Die genetische Verwandtschaft zwischen Tieren ist sehr wichtig bei der Zuchtwertschätzung. Wie wir im Kapitel zur Verwandtschaft schon gesehen hatten, zeigen verwandte Tiere eine erhöhte Wahrscheinlichkeit Kopien des gleichen Ahnen-Allels zu tragen. Im Kapitel BLUP-Zuchtwertschätzung werden wir sehen, dass genetische Covarianzen zwischen Tieren als Informationsquellen verlangt werden. Die genetischen Covarianzen zwischen Tieren sind durch die Verwandtschaftsbeziehungen zwischen den Tieren bestimmt. Technisch gesehen wird die additiv genetische Verwandtschaftsmatrix $A$ und insbesondere ihre Inverse $A^{-1}$ eine wichtige Rolle spielen bei der BLUP-Zuchtwertschätzung.


## Verwandtschaftsmatrix
Im Kapitel "Verwandtschaft und Inzucht" wurde bereits besprochen, wie die Verwandtschaftsgrade zwischen Tieren und die Inzuchtkoeffizienten von Tieren berechnet werden. Wir haben auch einen rekursiven Algorithmus angeschaut, welcher es uns erlaubt die ganze Verwandtschaftsmatrix aufzustellen. Die Verwandtschaftsmatrix enthält sehr viel Informationen über die Struktur einer Population. Als Nebenprodukt erhalten wir auch die Inzuchtkoeffizienten aller Tiere in unserer Population. Es gibt auch spannende Möglichkeiten die Verwandtschaftsmatrix graphisch darzustellen. Eine Möglichkeit ist die sogenannten Heatmap. Als Beispiel können wir die Verwandtschaftsmatrix aus dem Kapitel "Verwandtschaft und Inzucht", wie folgt in eine Heatmap verwandeln. Das Pedigree in Listenformat ist nachfolgend gezeigt.

```{r ExamplePedigree, results='markup'}
nNrAni <- 10
suppressPackageStartupMessages(library(pedigreemm))
pedEx1 <- pedigree(sire = as.integer(c(NA,NA,NA,NA,1,3,3,6,6,8)), 
                   dam  = as.integer(c(NA,NA,NA,NA,2,2,4,5,7,9)), 
                   label = as.character(1:nNrAni))
### # show the pedigree
print(pedEx1)
### # compute relationship matrix
matApedEx1 <- as.matrix(getA(pedEx1))
```

Anhand der Verwandtschaftsmatrix $A$ 

```{r RelMatFinalResult, results='asis'}
cat("$$A = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matApedEx1, pnDigits = 4), collapse = "\n"))
cat("\\right]\n")
cat("$$\n")
```

lässt sich dann die folgende Heatmap erzeugen. Die nachfolgenden R-Statements zeigen gleich, wie eine Heatmap in R erzeugt wird, vorausgesetzt, dass das Pedigree in einer Matrix mit Namen `matApedEx1` gespeichert ist.

```{r PedHeadMap, echo=TRUE, fig.width=4}
library(lattice)
new.palette=colorRampPalette(c("black","red","yellow","white"),space="rgb")
levelplot(matApedEx1[1:ncol(matApedEx1),ncol(matApedEx1):1],col.regions=new.palette(20))
```


## Zerlegung der Verwandtschaftsmatrix
Die Verwandtschaftsmatrix $A$ kann in ein Produkt von drei Faktoren zerlegt werden. Diese Zerlegung lautet 

\begin{equation}
A = LDL^T
\label{eq:RelMatFact}
\end{equation}

wobei $L$ eine linke untere Dreiecksmatrix ist und $D$ einer Diagonalmatrix entspricht. Aufgrund dieser Zerlegung lässt sich die Inverse $A^{-1}$ der Verwandtschaftsmatrix $A$ sehr einfach berechnen. 

### Herleitung der Zerlegung von $A$
Die Herleitung der Zerlegung in (\ref{eq:RelMatFact}) basiert auf der Tatsache, dass die Varianz der Zuchtwerte dem Produkt aus Verwandtschaftsmatrix $A$ und genetisch-additiver Varianz $\sigma_a^2$ entspricht. In Matrix-Vektor-Schreibweise heisst das

\begin{equation}
var(a) = A * \sigma_a^2
\label{eq:BvCoVarMat}
\end{equation}

wobei $a$ der Vektor mit den Zuchtwerten aller Tiere in der Population darstellt und $A$ der Verwandtschaftsmatrix entspricht.

Der Zuchtwert $a_i$ eines Tieres $i$ mit Mutter $d$ und Vater $s$ lässt sich zerlegen als

\begin{equation}
a_i = {1\over 2}\ a_s + {1\over 2}\ a_d + m_i
\label{eq:BvAniDecomp}
\end{equation}

wobei $a_s$ und $a_d$ die Zuchtwerte der Eltern $s$ und $d$ von Tier $i$ ist und $m_i$ dem "Mendelian Sampling"-Effekt entspricht. Mendelian Sampling-Effekte entstehen durch die zufällige Auswahl der Elternallele für die Nachkommen. Durch diesen zufälligen Auswahlprozess können bei Geschwistern eine Häufung von Allelen mit positiver (oder negativer) Wirkung auftreten. Somit haben Vollgeschwister nicht den gleichen Zuchtwert. Diese Variation der Zuchtwerte unter Vollgeschwister wird mit den $m_i$-Effekten modelliert.

In Matrix-Vektor-Schreibweise können wir die Zerlegung in (\ref{eq:BvAniDecomp}) für die gesamte Population schreiben als 

\begin{equation}
a = P * a + m
\label{eq:BvAniDecompMat}
\end{equation}

### Ein Beispiel
Zur Veranschaulichung verwenden wir das folgende Beispiel. Gegeben sei das folgende Pedigree

```{r PedEx1, results='markup'}
nNrAni <- 6
pedEx2 <- pedigree(sire = c(NA,NA,1,1,4,5),
                   dam = c(NA,NA,2,NA,3,2),
                   label = as.character(1:nNrAni))
print(pedEx2)
```

Die Zerlegung (\ref{eq:BvAniDecomp}) für Tier $3$ mit bekannten Eltern $1$ und $2$ lautet

$$a_3 = {1\over 2}\ a_1 + {1\over 2}\ a_2 + m_3$$

Analog dazu für Tier $4$ mit bekanntem Vater $1$ und unbekannter Mutter

$$a_4 = {1\over 2}\ a_1 + m_4$$

Für Tiere mit unbekannten Eltern, wie $1$ oder $2$ ist der Zuchtwert einfach dem $m_i$ Effekt. Somit ist

$$a_1 = m_1$$ und $$a_2 = m_2$$

Fassen wir die Zerlegungen aller Tiere zusammen, so resultiert


```{r ZwZerlMat, results='asis'}
cat("$$\\left[")
cat(paste(sGetTexMatrix(as.matrix(vecGetVecElem("a", nNrAni), ncol=1)), collapse = "\n"))
cat("\\right]\n")
cat(" = \\left[")

cat("\\right]\n")
cat("$$\n")
```






```{r WriteTableOfAbbreviations, results='hide'}
r6ob_abbrtable$writeToTsvFile()
```
<!-- END of document                 -- 
  -- Below this must not be anything --> 
