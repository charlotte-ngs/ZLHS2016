---
title:  Züchtungslehre - Berechnung der Inzucht
author: Peter von Rohr
date: 2016-11-04
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results = 'asis')
devtools::load_all()
```

```{r DocumentStatus, eval=FALSE}
r6obj_docstat <- rmddochelper::R6ClassDocuStatus$new()
r6obj_docstat$set_current_status(psVersion = "0.0.901",
                                 psStatus  = "Initialisation",
                                 psProject = "ZL_HS_2016")
r6obj_docstat$include_doc_stat(psTitle = "## Document Status")
```


```{r TableAbbreviation}
r6ob_abbrtable <- rmddochelper::R6ClassTableAbbrev$new()
### # include table of abbreviations only, if there are any
if (!r6ob_abbrtable$is_empty_abbr())
  r6ob_abbrtable$include_abbr_table(psAbbrTitle = "## Abbreviations")
```

## Einleitung
Im Kapitel __Inverse Verwandtschaftsmatrix__ haben wir besprochen, wie die inverse Verwandtschaftsmatrix direkt aufgestellt werden kann. Die verwendete Methode basiert auf der LDL-Zerlegung der Matrix $A$, wobei die Inversen der Matrizen $L$ und $D$ einfacher zu berechnen sind als jene von $A$. 

Die Inverse $D^{-1}$ ist eine Diagonalmatrix, deren Elemente von den Inzuchtkoeffizienten der Tiere abhängen. Die Inzuchtkoeffizienten erscheinen auf der Diagonalen der Verwandtschaftsmatrix. Also müssten wir für die Berechnung der Inzuchtkoeffizienten die komplette Verwandtschaftsmatrix aufstellen. Für sehr grosse Populationen ist das zu aufwändig. Wir brauchen also eine effizientere Methode zur Berechnung der Inzuchtkoeffizienten.


## Berechnung der Inzuchtkoeffizienten
Grundsätzlich gibt es zwei Arten die Inzuchtkoeffizienten zu berechnen, ohne die gesamte Verwandtschaftsmatrix aufzustellen.

1. Cholesky-Zerlegung der Verwandtschaftsmatrix
2. Pfadkoeffizientenmethode


## Cholesky-Zerlegung der Verwandtschaftsmatrix
Die Bezeichnung dieser Methode ist etwas irreführend, da wir ja die Verwandtschaftsmatrix explizit nicht kennen und deshalb auch nicht zerlegen können. Viel mehr wollen wir günstige Eigenschaften der Cholesky-Zerlegung der Verwandtschaftsmatrix ausnützen um die Inzuchtkoeffizienten effizient berechnen zu können. Zur Ableitung der Eigenschaften der Cholesky-Zerlegung, nehmen wir vorübergehend an, dass wir die Verwandtschaftsmatrix $A$ kennen. 

Bei bekannter Verwandtschaftsmatrix $A$ ist deren Cholesky-Zerlegung definiert als 

\begin{equation}
A = R * R^T
\label{eq:CholMatA}
\end{equation}

wobei $R$ eine linke untere Dreiecksmatrix ist. Aufgrund der Dreiecksstruktur von $R$ lassen sich die Diagonalelemente von $A$ berechnen als Summen der quadrierten Elemente von $R$ bis zur Diagonalen. Als Formel bedeutet das 

\begin{equation}
a_{ii} = \sum_{j=1}^i r_{ij}^2
\label{eq:DiagElemMatA}
\end{equation}

Für ein kleines Beispiel einer $3\times 3$ Matrix $A$ sieht das wie folgt aus

```{r SmallExCholA}
nAnzAni <- 3
matA <- matGetMatElem(psBaseElement = "a", pnNrRow = nAnzAni, pnNrCol = nAnzAni)
matR <- matLowerTri(psBaseElement = "r", pnNrRow = nAnzAni, pnNrCol = nAnzAni)
cat("$$\\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matA), collapse = "\n"))
cat("\\right] \n")
cat(" = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matR), collapse = "\n"))
cat("\\right] \n")
cat(" * \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = t(matR)), collapse = "\n"))
cat("\\right] \n")
cat("$$\n")
```

Für das gezeigte Beispiel berechnen wir die Diagonalelemente von $A$ als

\begin{eqnarray}
  a_{11} &=& r_{11}^2 \nonumber\\
  a_{22} &=& r_{21}^2 + r_{22}^2\nonumber\\
  a_{33} &=& r_{31}^2 + r_{32}^2 + r_{33}^2\nonumber
\label{MatADiag}
\end{eqnarray}

Die Gleichung (\ref{eq:DiagElemMatA}) zeigt, wie die Diagonalelemente $a_{ii}$ der Verwandtschaftsmatrix $A$ und somit die Inzuchtkoeffizienten aufgrund einer Zeile aus der Matrix $R$ berechnet werden können. Als nächstes müssen wir klären, wie die Elemente der Matrix $R$ berechnet werden können.


### Rekursive Berechnung der Matrix $R$
Wir setzen die LDL-Zerlegung der Verwandtschaftsmatrix $A$ der Cholesky-Zerlegung von $A$ gleich.

\begin{equation}
A = R * R^T = L * D * L^T
\label{eq:CholEqLdl}
\end{equation}

Schreiben wir die Matrix $R$ als Produkt aus den Matrizen $L$ und $S$ und setzen das in Gleichung (\ref{eq:CholEqLdl}) ein, dann folgt 

\begin{equation}
A = R * R^T = L * S * (L * S)^T = L * S * S^T * L^T= L * D * L^T
\label{eq:CholRLSEqLdl}
\end{equation}

Aus Gleichung (\ref{eq:CholRLSEqLdl}) sehen wir, dass 

$$D = S * S^T$$

und somit ist $S$ eine Diagonalmatrix deren Elemente gegeben ist durch $s_{ii} = \sqrt{d_{ii}}$. Schauen wir uns die Zerlegung 

$$R = L * S$$

der Matrix $R$ an unserem kleinen $3\times 3$ Beispiel an

\begin{equation}
```{r RlsDecompEx}
matL <- matLowerTri(psBaseElement = "l", pnNrRow = nAnzAni, pnNrCol = nAnzAni, pvecDiag = 1)
matS <- matDiag(psBaseElement = "s", pnNrRow = nAnzAni, pnNrCol = nAnzAni)
cat("\\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matR), collapse = "\n"))
cat("\\right]  = \n")
cat("\\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matL), collapse = "\n"))
cat("\\right]  * \n")
cat("\\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matS), collapse = "\n"))
cat("\\right]\n")
```
\label{eq:SmallExRLS}
\end{equation}

wird klar, dass aufgrund der speziellen Strukturen von $L$ und $S$ gilt, dass die Diagonalelemente von $R$ den Diagonalelementen von $S$ entsprechen. Es gilt somit 

$$r_{ii} = s_{ii} = \sqrt{d_{ii}}$$

Im Kapitel __Inverse Verwandtschaftsmatrix__ hatten wir gesehen, dass die Diagonalelemente $d_{ii}$ der Matrix $D$ aufgrund der Inzuchtgrade der Eltern berechnet werden können

$$d_{ii} = {1\over 2}\ - {1\over 4}\ (F_s + F_d) = 1 - 0.25(a_{ss} + a_{dd})$$

wobei $s$ und $d$ die Eltern von $i$ sind. Die Werte für $a_{ss}$ und $a_{dd}$ werden aufgrund der Gleichung (\ref{eq:DiagElemMatA}) berechnet. 

Aufgrund des kleinen Beispiels in (\ref{eq:SmallExRLS}) werden Offdiagonalelement $r_{ij}$ der Matrix $R$ berechnet als 

\begin{equation}
r_{ij} = l_{ij} * s_{jj}
\label{eq:ComputeRij}
\end{equation}

Die Elemente $l_{ij}$ aus Matrix $L$ werden als Durchschnitt der Elemente $l_{sj}$ und $l_{dj}$ berechnet, wobei $s$ und $d$ die Eltern von $i$ sind. Setzen wir dies in (\ref{eq:ComputeRij}) ein, dann folgt

\begin{eqnarray}
r_{ij} &=& l_{ij} * s_{jj} \nonumber\\
       &=& {1\over 2}(l_{sj} + l_{dj}) * s_{jj} \nonumber\\
       &=& {1\over 2}(r_{sj} + r_{dj})
\label{eq:ComputeRijRec}
\end{eqnarray}

wobei wir im letzten Schritt von (\ref{eq:ComputeRijRec}) die Definition aus (\ref{eq:ComputeRij}) umgekehrt angewendet haben. 

Somit haben wir die Diagonalelemente $r_{ii}$ und $r_{ij}$ rekursiv berechnet. Unter der gängigen Bedingung, dass im Pedigree die Tiere nach ihrem Alter sortiert sein müssen, können wir die Rekursionen auflösen.


## Unser Beipielpedigree






```{r WriteTableOfAbbreviations, results='hide'}
r6ob_abbrtable$writeToTsvFile()
```
<!-- END of document                 -- 
  -- Below this must not be anything --> 
